---
title: "Differential Binding"
author: "Dominique Paul"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

suppressPackageStartupMessages({
  library(dplyr)
  library(epiwraps)
  library(Rsubread)
  library(SummarizedExperiment)
  library(sechm)
  library(edgeR)
  library(Rsamtools)
  library(rtracklayer)
  library(ggplot2)
  library(AnnotationHub)
})
```


# Call peaks (bam -> bed)

Note: We only have two control samples as the first isogenic sample was not uploaded to encode. We call the peaks manually for the 12hDEX and 0h DEX data, as no bed files were uploaded for the 0h DEX data. We call the peak for both groups here to ensure that the peak calling method applied is the same.

```{bash engine.opts='-l', eval=FALSE}

macs2 callpeak --outdir ../data/single_replicate_peaks/peaks \
  -n Chip_GR_12hDex_s1 \
  --gsize dm \
  -t ../data/single_replicate_peaks/dex12h/Chip_GR_12hDex_s1.bam \
  -c ../data/single_replicate_peaks/dex12h/Chip_GR_12hDex_s1_input.bam \
  --nomodel \
  --extsize 200

macs2 callpeak --outdir ../data/single_replicate_peaks/peaks \
  -n Chip_GR_12hDex_s2 \
  --gsize dm \
  -t ../data/single_replicate_peaks/dex12h/Chip_GR_12hDex_s2.bam \
  -c ../data/single_replicate_peaks/dex12h/Chip_GR_12hDex_s2_input.bam \
  --nomodel \
  --extsize 200

macs2 callpeak --outdir ../data/single_replicate_peaks/peaks \
  -n Chip_GR_12hDex_s3 \
  --gsize dm \
  -t ../data/single_replicate_peaks/dex12h/Chip_GR_12hDex_s3.bam \
  -c ../data/single_replicate_peaks/dex12h/Chip_GR_12hDex_s3_input.bam \
  --nomodel \
  --extsize 200

macs2 callpeak --outdir ../data/single_replicate_peaks/peaks \
  -n Chip_GR_control_s2 \
  --gsize dm \
  -t ../data/single_replicate_peaks/control/Chip_GR_control_s2.bam \
  -c ../data/single_replicate_peaks/control/Chip_GR_control_s2_input.bam \
  --nomodel \
  --extsize 200

macs2 callpeak --outdir ../data/single_replicate_peaks/peaks \
  -n Chip_GR_control_s3 \
  --gsize dm \
  -t ../data/single_replicate_peaks/control/Chip_GR_control_s3.bam \
  -c ../data/single_replicate_peaks/control/Chip_GR_control_s3_input.bam \
  --nomodel \
  --extsize 200
```

# Differential binding analysis

Only the sample 2 and 3 of the 12h Dex treated group have peaks. The control samples 2 and 3 (1 was not uploaded) as well as treatment sample 1 have no peaks.

```{r load peaks}
# load peaks
c2 <- import.bed15("../data/single_replicate_peaks/peaks/Chip_GR_control_s2_peaks.narrowPeak", format="narrowPeak")
c3 <- import.bed15("../data/single_replicate_peaks/peaks/Chip_GR_control_s3_peaks.narrowPeak", format="narrowPeak")
t12_1 <- import.bed15("../data/single_replicate_peaks/peaks/Chip_GR_12hDex_s1_peaks.narrowPeak", format="narrowPeak")
t12_2 <- import.bed15("../data/single_replicate_peaks/peaks/Chip_GR_12hDex_s2_peaks.narrowPeak", format="narrowPeak")
t12_3 <- import.bed15("../data/single_replicate_peaks/peaks/Chip_GR_12hDex_s3_peaks.narrowPeak", format="narrowPeak")

peaks <- list("c2"=c2, "c3"=c3,
              "t12_1"=t12_1, "t12_2"=t12_2, "t12_3"=t12_3)

bamfiles <- c("../data/single_replicate_peaks/control/Chip_GR_control_s2.bam",
                 "../data/single_replicate_peaks/control/Chip_GR_control_s3.bam",
                 "../data/single_replicate_peaks/dex12h/Chip_GR_12hDex_s1.bam", 
                 "../data/single_replicate_peaks/dex12h/Chip_GR_12hDex_s2.bam", 
                 "../data/single_replicate_peaks/dex12h/Chip_GR_12hDex_s3.bam")
```

```{r show overlap}
regionUpset(peaks)
```

For downstream analysis, we'll want to have a single set of regions that contains all the relevant regions.
Regions that occur only in one sample are not really important, so we could filter them out, and then merge the regions.

```{r}
merged_peaks <- reduce(unlist(GRangesList(peaks)), with.revmap=TRUE)
merged_peaks <- granges(merged_peaks[lengths(merged_peaks$revmap)>1]) # we could change the >1 here to require a higher minimum number of samples

# annotate peaks 
ah <- AnnotationHub()
ensdb <- ah[["AH98047"]] # AH89211
merged_peaks <- annotateRegions(merged_peaks, ensdb)

merged_peaks
```


## Counting the number of reads in each peak, in each sample

```{r}
# create a vector with all the peak files in it, and giving it clean names:
# bamfiles <- list.files("aligned", pattern="bam$", full=TRUE)
# we give the samples clean names:
# names(bamfiles) <- gsub("\\.bam","",basename(bamfiles))

# for counting, we need to convert our GRanges object to a data.frame with the following specifications:
anno <- cbind(name=as.character(merged_peaks), as.data.frame(merged_peaks))
anno$width <- NULL
colnames(anno) <- c("GeneID", "Chr", "Start", "End", "Strand")

fc <- featureCounts( files=bamfiles,    # the files in which we want to count reads
                     isPairedEnd=FALSE,
                     annot.ext=anno,    # the regions in which we want to count reads
                     readExtension3=50, # extend the reads by 50bp
                     nthreads=3         # multithreading (to speed up)
                    )
```

We're going to package this data into a SummarizedExperiment (SE) object:

```{r}
se <- SummarizedExperiment(assays=list(counts=fc$counts), rowRanges=merged_peaks)
colnames(se) <- c("C2","C3","T1","T2","T3")
# we keep the counts in the input, but not as a normal sample:
# rowData(se)$input.count <- assay(se)[,"input.bam"]
# se <- se[,colnames(se)!="input.bam"]
# we assign the conditions:
# se$condition  equivalent to  colData(se)$condition
se$condition <- c("Control","12hDEX")[1+grepl("T",colnames(se))]
# is equivalent to:
# se$condition <- c("CTRL","CTRL","CTRL","MUT","MUT","MUT","MUT")
se
```


## Normalization

We take a look at the counts

```{r}
head(assay(se))
```
We plot the counts for the first 500 regions --> clear difference between control and 12h DEX

```{r}
sechm::sechm(se, head(row.names(se),500), assayName="counts", do.scale=TRUE, top_annotation = c("condition"))
```

Or another way to look at it:

```{r}
plot(assay(se)[,1], assay(se)[,2], log="xy")
abline(a=0, b=1)
```

The usual way we represent this kind of relation is through a M-A plot:

```{r}
edgeR::maPlot(assay(se)[,1], assay(se)[,2], lowess=TRUE, ylab="M (log2 foldchange)", 
              xlab="A (mean log-count)"); abline(h=0, lty="dashed")
```



The standard approach would be to use the TMM normalization. HOWEVER, because some of our samples appear to have no peaks at all normalisation might distort the counts. We want to replace the library size column by the read counts.

```{r}
read_counts <- sapply(bamfiles, function(bamfile){
  length(GenomicAlignments::readGAlignments(bamfile))
})

dds <- DGEList(assay(se), group=se$condition)

# We skip this due to the different peak per sample
# dds$samples$lib.size <- read_counts
# dds <- calcNormFactors(dds)
assays(se)$tmm.logcpm <- log1p(cpm(dds))
sechm::sechm(se, head(row.names(se),500), assayName="tmm.logcpm", do.scale = TRUE)
```

We now have high values in the control data too. The normalisation seems to have worked.

We run the differential analysis:

```{r}
dds <- estimateDisp(dds)

merged_peaks_df <- as.data.frame(merged_peaks) %>%
  mutate(name = paste0(seqnames,":", start, "-", end)) %>%
  dplyr::select(c(name, distance2nearestTSS, nearestTSS, nearestTSS.gene_name))

et <- as.data.frame(topTags(exactTest(dds),n=Inf)) %>% 
  tibble::rownames_to_column("name") %>%
  left_join(merged_peaks_df, by="name")

wb <- createWorkbook()
sheet_name <- "Differential binding"
addWorksheet(wb, sheet_name)
writeData(wb, sheet = sheet_name, et)
saveWorkbook(wb, "../docs/downloads/Q9_differential_binding.xlsx", overwrite = TRUE)

saveRDS(et, file="../data/results/differential_binding_results.rds")
saveRDS(merged_peaks, file="../data/results/merged_peaks.rds")
```


Plot as a volcano plot:

```{r, fig.width=10, fig.height=7}
ggplot(et, aes(logFC, -log10(FDR))) + geom_point() + 
  geom_hline(yintercept=-log10(0.05), linetype="dashed") +
  theme_ipsum_rc() +
  labs(title=paste0("Differential binding results for ", dim(et)[1], " genes")) +
  ggrepel::geom_text_repel(data=et,
                           aes(x=logFC, y=-log10(FDR), label=nearestTSS.gene_name, size=4),
                           show.legend=F,
                           max.overlaps = 30)
```

At a first glance, there seems to be roughly as many regions that increase in binding as regions that decrease in binding.
Does this sound likely to you?

Let's look again at an MA plot between a ctrl and a mutant:

```{r}
edgeR::maPlot(assay(se)[,2], assay(se)[,5], lowess=TRUE); abline(h=0, lty="dashed")
```


## Normalization based on top peaks

```{r}
# we first calculate the peaks' median enrichment against the input
# rowData(se)$medianEnr <- matrixStats::rowMedians(assays(se)$tmm.logcpm - log1p(rowData(se)$input.count))
# we then select the top peaks based on that
# w <- head(order(rowData(se)$medianEnr, decreasing=TRUE), 200)
# we then estimate TMM normalization factors based on that:
# dds2 <- calcNormFactors(dds[w,,keep.lib.sizes=TRUE])
# dds2$samples
```

Notice that the `norm.factors` column is different than the one we previous had. We can now inject them into the full object:

```{r}
# dds$samples$norm.factors <- dds2$samples$norm.factors
```

We compute again the normalized logcpm and plot our matrix:

```{r}
assays(se)$logcpm <- log1p(cpm(dds))
sechm::sechm(se, head(row.names(se),500), assayName="logcpm", do.scale = TRUE)
```

We can now do the differential analysis using these factors

```{r}
dds <- estimateDisp(dds)
et <- as.data.frame(topTags(exactTest(dds),Inf))
head(et)
ggplot(et, aes(logFC, -log10(FDR))) + geom_point() + 
  geom_hline(yintercept=-log10(0.05), linetype="dashed")
```


We could also visualize the top results in this way:

```{r}
sechm(se, head(row.names(et),50), assayName="logcpm", do.scale=TRUE, row_title="Top 50 differentially-bound regions")
```


## Applying the normalization for visualization

For comparison, we first plot using background normalization:

```{r, fig.width=8, fig.height=4}
tracks <- list("C2"="../data/single_replicate_peaks/control/Chip_GR_control_s2.bigWig",
               "C3"="../data/single_replicate_peaks/control/Chip_GR_control_s3.bigWig",
               "t12_1"="../data/single_replicate_peaks/dex12h/Chip_GR_12hDex_s1.bigWig",
               "t12_2"="../data/single_replicate_peaks/dex12h/Chip_GR_12hDex_s2.bigWig",
               "t12_3"="../data/single_replicate_peaks/dex12h/Chip_GR_12hDex_s3.bigWig")
m <- signal2Matrix(tracks, merged_peaks)
plotEnrichedHeatmaps(m)
```

We now apply the normalization factors we calculated:

```{r, fig.width=8, fig.height=4}
# we first make sure that the order of the samples matches:
cbind(colnames(dds), names(m))
m2 <- rescaleSignalMatrices(m, scaleFactors=1/dds$samples$norm.factors)
plotEnrichedHeatmaps(m2)
```

Let's look at it using just the average signal plots:

```{r, fig.width=8, fig.height=4}
d1 <- meltSignals(m)
d1$condition <- gsub("[0-9]","",d1$sample)
d1$condition <- ifelse(d1$condition=="C", "Control", "12hDEX")
p1 <- ggplot(d1, aes(position, mean, group=sample, colour=condition)) + geom_line() + ggtitle("Coverage normalization")
d2 <- meltSignals(m2)
d2$condition <- gsub("[0-9]","",d2$sample)
d2$condition <- ifelse(d2$condition=="C", "Control", "12hDEX")
p2 <- ggplot(d2, aes(position, mean, group=sample, colour=condition)) + geom_line() + ggtitle("Top peaks normalization")
ggpubr::ggarrange(p1, p2, ncol=2)
```

## Using background normalization

```{r}
nf <- bwNormFactors(tracks)
m3 <- rescaleSignalMatrices(m, scaleFactors=1/nf)
d3 <- meltSignals(m3)
d3$condition <- gsub("[0-9]","",d3$sample)
d3$condition <- ifelse(d3$condition=="C", "Control", "12hDEX")
p3 <- ggplot(d3, aes(position, mean, group=sample, colour=condition)) + geom_line() + ggtitle("Background normalization")
ggpubr::ggarrange(p2, p3, ncol=2)
```
















